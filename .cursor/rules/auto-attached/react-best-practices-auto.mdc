# React Best Practices

## Context

- Applies to all React component files
- Ensures modern React 19 patterns and best practices
- Maintains code quality and performance standards

## Critical Rules

- Use functional components with hooks for cleaner code
- Manage state effectively with Context API or state management libraries
- Optimize performance with React.memo and useCallback when needed
- Ensure accessibility by following ARIA guidelines
- Write unit tests for components using React Testing Library
- Use descriptive component and function names
- Implement proper error boundaries and error handling
- Follow React 19 patterns and new features

## Examples

<example>
  // ✅ DO: Use functional components with hooks
  const UserProfile = ({ userId }: { userId: string }) => {
    const [user, setUser] = useState<User | null>(null);
    
    useEffect(() => {
      fetchUser(userId).then(setUser);
    }, [userId]);
    
    return <div>{user?.name}</div>;
  };
</example>

<example type="invalid">
  // ❌ DON'T: Use class components unnecessarily
  class UserProfile extends React.Component {
    state = { user: null };
    
    componentDidMount() {
      fetchUser(this.props.userId).then(user => 
        this.setState({ user })
      );
    }
  }
</example>
description:
globs:
alwaysApply: false
---
