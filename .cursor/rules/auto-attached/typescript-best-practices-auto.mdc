# TypeScript Best Practices

## Context

- Applies to all TypeScript and TSX files
- Ensures type safety and code quality
- Maintains consistent TypeScript patterns

## Critical Rules

- Use strict null checks to avoid runtime errors
- Prefer interface over type for defining object shapes
- Utilize type guards and assertions for better type safety
- Implement proper type inference to reduce redundancy
- Keep types organized in separate files for maintainability
- Use descriptive type names and avoid any type
- Implement proper error handling with typed errors
- Use generics for reusable component types

## Examples

<example>
  // ✅ DO: Use interfaces for object shapes
  interface User {
    id: string;
    name: string;
    email: string;
  }
  
  const getUser = (id: string): Promise<User> => {
    return fetch(`/api/users/${id}`).then(res => res.json());
  };
</example>

<example type="invalid">
  // ❌ DON'T: Use any type or avoid typing
  const getUser = (id: any) => {
    return fetch(`/api/users/${id}`).then(res => res.json());
  };
</example>
description:
globs:
alwaysApply: false
---
